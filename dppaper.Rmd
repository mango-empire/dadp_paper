---
title: "gdpR: An R Package for studying differentially private algorithms"
date: "2023-11-01"
abstract: >
    This paper serves as a reference and introduction on using the $gdpR$ R
    package. The goal of this package is to provide some tools for exploring the
    impact of different privacy regimes on a Bayesian analysis. A strength of
    this framework is the ability to target the exact posterior in settings
    where the likelihood is too complex to analytically express.
draft: true
author:  
  - name: Jordan A. Awan
    affiliation: Purdue University
    address:
    - Department of Statistics
    - West Lafayette, IN 47907
    url: https://www.britannica.com/animal/quokka
    email: jawan@purdue.edu
  - name: Kevin Eng
    affiliation: Rutgers University
    address:
    - Department of Statistics
    - Piscataway, NJ 08854
    url: https://www.britannica.com/animal/quokka
    email: ke157@stat.rutgers.edu
  - name: Robin Gong
    affiliation: Rutgers University
    address:
    - Department of Statistics
    - Piscataway, NJ 08854
    url: https://www.britannica.com/animal/quokka
    email: ruobin.gong@rutgers.edu
  - name: Nianqiao Phyllis Ju
    affiliation: Purdue University
    address:
    - Department of Statistics
    - West Lafayette, IN 47907
    url: https://www.britannica.com/animal/quokka
    email: nianqiao@purdue.edu
  - name: Vinayak A. Rao
    affiliation: Purdue University
    address:
    - Department of Statistics
    - West Lafayette, IN 47907
    url: https://www.britannica.com/animal/quokka
    email: varao@purdue.edu
type: package
output: 
  rjtools::rjournal_article:
    self_contained: yes
    toc: no
bibliography: RJreferences.bib

---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
library(ggplot2)
library(kableExtra)
library(tidyverse)
library(knitr)
```



# Introduction

(cliche...)
The ease and pervasiveness of modern data collection technologies has raised
concerns about data privacy. [@Dwork2013] introduced the differential privacy
framework as a means to rigorously define privacy. 


# Using \CRANpkg{gdpR}

The package is structured around the two functions `gdp_sample` and
`new_privacy`. The first function is used to draw samples from the 
posterior. The second function is used to create the privacy model. Since the 
input to these functions are R functions, there is a great deal of freedom
left up to user. The next two sections describe in detail the inputs into
these functions and highlight some considerations that should be taken
into account in order avoid slow or unexpected behavior.

## Sampling

The main function in \pkg{gdpR} is the `gdp_sample` function. The call
signature of the function is:

```{r, echo = TRUE, eval = FALSE}
gdp_sample(data_model, sdp, nobs, init_par, niter = 2000, warmup = floor(niter / 2),
           chains = 1, varnames = NULL)
```

The three required inputs into `gdp_sample` function are the privacy model (`data_model`), the value
of the  observed privatized statistic (`sdp`), and the total number of observations 
in the complete data (`nobs`) [MAKE SURE NOTATION IS INTRODUCED]. The \CRANpkg{gdpR}
package is best suited for problems where the complete data can be represented in
tabular form. This is because internally, it is represented as a matrix.

The optional arguments are the number of mcmc draws (`niter`), the 
burn in period (`warmup`), number of chains (`chains`) and character
vector that names the parameters. Running multiple chains can be done in parallel
using the \CRANpkg{furrr} package. Additionally, progress can be monitored
using the \CRANpkg{progressr} package.


The `data_model` input is a `privacy`
object that can be constructed using the `new_privacy` constructor. The
process of constructing a `privacy` object will be discussed in the next section.

## Privacy Model

Creating a privacy model is done using the `new_privacy` constructor. The 
main arguments consist of the four components as outlined in the methodology
section.

```{r, echo=TRUE, eval=FALSE}
new_privacy(post_smpl = NULL, lik_smpl = NULL, ll_priv_mech = NULL,
            st_calc = NULL, add = FALSE, npar = NULL)
```

The internal implementation of the DA algorithm in `gdp_sample` requires
some care in how each component in constructed. 

* `lik_smpl` is an R function that samples from the likelihood. Its
call signature should be `lik_smpl(theta)` where `theta` is a vector
representing the likelihood model parameters being estimated. This function
must work with the supplied initial parameter provide in the `init_par`
argument of `gdp_sample`. The sampler need not be vectorized and vectorizing
the sampler will not add any speed benefits.


* `post_smpl` is a function which represents the posterior sampler. It should
have the call signature `post_smpl(dmat, theta)`. Where `dmat` is the 
complete data. This sampler can be generated by wrapping mcmc samplers generated from other R packages 
(e.g. \CRANpkg{rstan}, \CRANpkg{fmcmc}, \CRANpkg{adaptMCMC}).
If using this approach, it is recommended to avoid using packages such as \CRANpkg{mcmc}
whose implementation clashes with `gdp_sample`. In the case of \CRANpkg{mcmc},
the Metropolis-Hastings loop is implemented in C which incurs a very large overhead
in `gdp_sample` since it is reinitialized every iteration. In general, repeatedly calling
an R function that hooks into C code is slow. (NOT QUITE ACCURATE FIX LATER)

* `ll_priv_mech` is an R function that represents the log-likelihood of 
$\eta(s_{sdp} \mid x)$. The function can output the log likelihood 
up to an additive constant.

* `st_calc` is an R function which calculates the summary statistic. The optional
argument `add` is a flag which represents whether $T$ is additive or not.



# Examples

## 2x2 Contingency Table
A common procedure when analyzing contingency tables is to estimate the 
odds ratio. Something something about safetab to connect back to DP (dont forget citation!). 
As a demonstration, we analyze the UC Berkeley admissions data, which is often
used as an illustrative example of Simpson's paradox. The question is whether
the data suggest there is bias against females during the college admissions 
process. Below is a table of the aggregate admissions result from six departments based on sex.


```{r, echo = FALSE}
set.seed(1)
tmp <- apply(UCBAdmissions, 3, identity, simplify=FALSE)
adm_cnf <- Reduce('+', tmp)
adm_prv <- round(adm_cnf + rnorm(4, mean = 0, sd = 100))
```


```{r, echo = FALSE}
kbl(list(adm_cnf, adm_prv), booktabs = TRUE) %>%
  kable_styling(position = 'center', latex_options = c("hold_position"))
```



```{r, echo = FALSE}
#generate 2x2 table data
x <- c(adm_cnf)
sdp <- c(adm_prv)
```

Below we walk through the process of defining a privacy model.


1. `lik_smpl`: Conditional on the table total, the table counts follow a multinomial
distribution. We can easily draw from this distribution using the
`rmultinom` function in the `base` stats package. Note, in this example,
the return value of one sample from `rmultinom` is a $4 \times 1$ matrix. In order to 
conform with `gdp_sample` we must convert the matrix to a vector.
    ```{r, echo = TRUE}
    lik_smpl <- function(theta) {
      c(rmultinom(1, 4526, theta))
    }
    ```
2. `post_smpl`: Given confidential data $X$ we can derive the posterior analytically
using a Dirichlet prior. In this example, we use a flat prior which
corresponds to Dirch(1) distribution. A sample from the Dirichlet distribution
can be generated using the gamma distribution via the following relation (INSERT)
    ```{r, echo = TRUE}
    post_smpl <- function(dmat, theta) {
      x <- c(dmat)
      t1 <- rgamma(length(theta), x + 1, 1)
      t1/sum(t1)
    }
    ```
3. `st_calc`: The complete data can be represented in two ways. Micro vs cell totals.
(what section to introduce?) This function must return a vector.
    ```{r, echo = TRUE}
    st_calc <- function(dmat) {
      c(dmat)
    }
    ```
4. `ll_priv_mech`: Privacy Mechanism
Guassian white noise is added to each cell total. Hence given
confidential data $(n_{11}, n_{22}, n_{12}, n_{21})$
\[
\eta(s_{dp} \mid x) = \prod \phi(s_{sd}; n_{ij}, 100^2)
\]
    ```{r, echo = TRUE}
    ll_priv_mech <- function(sdp, x) {
      dnorm(sdp - x, mean = 0, sd = 100, log = TRUE)
    }
    ```


<!-- end of list -->

Once privacy model has been defined we can run `gdp_sample`

```{r, echo = TRUE}
library(DPloglin)
dmod <- new_privacy(post_smpl = post_smpl,
                    lik_smpl = lik_smpl,
                    ll_priv_mech = ll_priv_mech,
                    st_calc = st_calc,
                    add = FALSE,
                    npar = 4)

gdp_out <- gdp_sample(dmod,
                  sdp = c(adm_prv),
                  nobs = 1,
                  niter = 6000,
                  warmup = 1000,
                  chains = 1,
                  init_par = rep(.25,4),
                  varnames = c("pi_11", "pi_21", "pi_12", "pi_22"))
```

results can be quickly summarized using the `summary` function

```{r,echo = FALSE}
summary(gdp_out)
```

Diagnostic checks can be done using the \pkg{Bayesplot} package.

```{r, fig.height=3, fig.width=5, fig.align='center'}
plot(gdp_out)
```

log odds distribution

```{r, fig.height=3, fig.width=5, fig.align='center'}
tv <- gdp_out$chain
or <- as.numeric((tv[,1] * tv[,4]) / (tv[,2] * tv[,3]))
quantile(or, c(.025, .50, .975))

ggplot(tibble(x=or), aes(x)) + geom_histogram() + xlim(-1,10)
```
(Insert gdp Analysis Here)

For clean data, a estimate for the odds ratio and a confidence interval
can be constructed using Woolf's method (i.e. A wald confidence interval).
It uses the fact that the log of the odds ratio is approximately 
normal for large sample sizes.
\[
\log\left(\dfrac{n_{11} \cdot n_{22}}{n_{12} \cdot n_{21}}\right) 
  \pm z_{\alpha/2}\sqrt{\dfrac{1}{n_{11}} + \dfrac{1}{n_{22}} + \dfrac{1}{n_{12}} + \dfrac{1}{n_{21}}}
\]

```{r, echo = TRUE}
or_confint <- function(x, alpha) {
  or <- log(x[1] * x[4]/ (x[2] * x[3]))
  se <- sqrt(sum(1/x))
  c(or - qnorm(alpha/2) * se, or + qnorm(alpha/2) * se)
}

#clean data
exp(or_confint(x, .95))

#privitized data
exp(or_confint(sdp, .95))
```


# Summary

This package is cool. You should install it.