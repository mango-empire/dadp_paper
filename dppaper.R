# Generated by `rjournal_pdf_article()` using `knitr::purl()`: do not edit by hand
# Please edit dppaper.Rmd to modify this file

## ----setup, include=FALSE-----------------------------------------------------
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE, eval.after = "fig.cap")
library(ggplot2)
library(kableExtra)
library(tidyverse)
library(knitr)


## ----echo=TRUE, eval=FALSE----------------------------------------------------
#> new_privacy(post_f = NULL, latent_f = NULL, priv_f = NULL,
#>             st_f = NULL, npar = NULL)


## ----echo = TRUE, eval = FALSE------------------------------------------------
#> dapper_sample(data_model, sdp, init_par, niter = 2000, warmup = floor(niter / 2),
#>            chains = 1, varnames = NULL)


## ----echo = FALSE-------------------------------------------------------------
#Original UCBAdmissions data.
cnf_df <- tibble(sex = c(1, 1, 0, 0),
                 status = c(1, 0, 1, 0),
                 n = c(1198, 1493, 557, 1278)) %>% uncount(n)

set.seed(1) 
ix <- sample(1:nrow(cnf_df), 400, replace = FALSE)
cnf_df <- cnf_df[ix,]

#Answers to be randomized
ri <- as.logical(rbinom(800, 1, 1/2)) 

#Randomized answers
ra <- rbinom(sum(ri), 1, 1/2)

#Create sdp
sdp <- c(cnf_df$sex, cnf_df$status)
sdp[ri] <- ra

prv_df <- tibble(sex = sdp[1:400], status = sdp[401:800])


## ----echo = FALSE-------------------------------------------------------------
tmp1_df <- cnf_df %>% mutate(sex = case_match(sex, 1 ~ "Male", 0 ~ "Female"),
                             status = case_match(status, 1 ~ "Admitted", 0 ~ "Rejected"))
tmp2_df <- prv_df %>% mutate(sex = case_match(sex, 1 ~ "Male", 0 ~ "Female"),
                             status = case_match(status, 1 ~ "Admitted", 0 ~ "Rejected"))
kbl(list(table(tmp1_df), table(tmp2_df)), booktabs = TRUE) %>%
  kable_styling(position = 'center', latex_options = c("hold_position"))


## ----echo = TRUE--------------------------------------------------------------
latent_f <- function(theta) {
  tl <- list(c(1,1), c(1,0), c(0,1), c(0,0))
  rs <- sample(tl, 400, replace = TRUE, prob = theta)
  do.call(rbind, rs)
}


## ----echo = TRUE--------------------------------------------------------------
 post_f <- function(dmat, theta) {
  sex <- dmat[,1]
  status <- dmat[,2]
  
  #Male & Admit
  x1 <- sum(sex & status)
  x2 <- sum(sex & !status)
  x3 <- sum(!sex & status)
  x4 <- sum(!sex & !status)

  x <- c(x1, x2, x3, x4)
    
  t1 <- rgamma(4, x + 1, 1)
  t1/sum(t1)
}


## ----echo = TRUE--------------------------------------------------------------
st_f <- function(i, xi, sdp) {
  x <- rep(0, 400 * 2)
  x[i] <- xi[1]
  x[i + 400] <- xi[2]
  x
}


## ----echo = TRUE--------------------------------------------------------------
priv_f <- function(sdp, tx) {
  t1 <- sum(sdp == tx)
  t1 * log(3/4) + (800 - t1) * log(1/4)
}


## ----echo = TRUE, eval = FALSE------------------------------------------------
#> #Original UCBAdmissions data.
#> cnf_df <- tibble(sex = c(1, 1, 0, 0),
#>                  status = c(1, 0, 1, 0),
#>                  n = c(1198, 1493, 557, 1278)) %>% uncount(n)
#> 
#> set.seed(1)
#> ix <- sample(1:nrow(cnf_df), 400, replace = FALSE)
#> cnf_df <- cnf_df[ix,]
#> 
#> #Answers to be randomized
#> ri <- as.logical(rbinom(800, 1, 1/2))
#> 
#> #Randomized answers
#> ra <- rbinom(sum(ri), 1, 1/2)
#> 
#> #Create sdp
#> sdp <- c(cnf_df$sex, cnf_df$status)
#> sdp[ri] <- ra


## ----echo = TRUE--------------------------------------------------------------
library(dapper)
library(furrr)
plan(multisession, workers = 4)

dmod <- new_privacy(post_f   = post_f,
                    latent_f = latent_f,
                    priv_f   = priv_f,
                    st_f     = st_f,
                    npar     = 4,
                    varnames = c("pi_11", "pi_21", "pi_12", "pi_22"))
                  
dp_out <- dapper_sample(dmod,
                  sdp = sdp,
                  niter = 6000,
                  warmup = 1000,
                  chains = 4,
                  init_par = rep(.25,4))


## ----eval = FALSE, echo = TRUE------------------------------------------------
#> library(progressr)
#> handlers(global = TRUE)
#> 
#> handlers("cli")
#> dp_out <- dapper_sample(dmod,
#>                   sdp = c(adm_prv),
#>                   niter = 10000,
#>                   warmup = 100,
#>                   chains = 4,
#>                   init_par = rep(.25,4))


## ----echo = FALSE-------------------------------------------------------------
summary(dp_out)


## ----trace-plot,  fig.cap="(Example 1) trace plots.", fig.height=3, fig.width=5, fig.align='center'----
plot(dp_out)


## ----post-or-density, fig.cap="(Example 1) posterior density estimate for the odds ratio using 16,000 MCMC draws.",  fig.height=3, fig.width=5, fig.align='center'----
tv <- dp_out$chain
or <- as.numeric((tv[,1] * tv[,4]) / (tv[,2] * tv[,3]))
ggplot(tibble(x=or), aes(x)) + geom_density() + xlim(0,10) + xlab("Odds Ratio")


## ----post-or-compare, fig.cap= caption,  echo = FALSE, fig.height=3, fig.width=5, fig.align='center'----
caption <- "(Example 1) comparison between using dapper and a naive Bayesian anaylsis on the
noise infused data and the original confidential data." 

set.seed(1)
confidential_data <- as.matrix(cnf_df)
cps <- t(sapply(1:20000, function(s) post_f(confidential_data, NULL)))
odds_male   <- cps[,1] / cps[,2]
odds_female <- cps[,3] / cps[,4]
odds_ratio_conf  <- odds_male/odds_female

set.seed(1)
noisy_data <- matrix(sdp, ncol = 2, byrow = FALSE)
cps <- t(sapply(1:20000, function(s) post_f(noisy_data, NULL)))
odds_male   <- cps[,1] / cps[,2]
odds_female <- cps[,3] / cps[,4]
odds_ratio_noisy  <- odds_male/odds_female

df1 <- tibble(confidential = odds_ratio_conf, noisy = odds_ratio_noisy) %>%
  pivot_longer(everything(), names_to = "group", values_to = "odds_ratio") %>%
  mutate(method = "naive")

df2 <- tibble(confidential = odds_ratio_conf, noisy = or) %>%
  pivot_longer(everything(), names_to = "group", values_to = "odds_ratio") %>%
  mutate(method = "dapper")

df <- rbind(df1,df2)

df %>%  ggplot(aes(odds_ratio, group = group, fill = group)) + 
  geom_density(alpha = .5) + 
  facet_wrap(~method) + 
  xlim(0,8) +
  xlab("Odds Ratio") +
  guides(fill= guide_legend(title= "Data")) + 
  theme(legend.position="bottom")


## ----echo = FALSE-------------------------------------------------------------
#Original UCBAdmissions data.
cnf_df <- tibble(sex = c(1, 1, 0, 0),
                 status = c(1, 0, 1, 0),
                 n = c(1198, 1493, 557, 1278)) %>% uncount(n)

set.seed(1) 
ix <- sample(1:nrow(cnf_df), 400, replace = FALSE)
rd <- dapper::rdnorm(4, 0, 6.25)


## ----echo = FALSE-------------------------------------------------------------
tmp_df <- cnf_df[ix,] %>% mutate(sex = case_match(sex, 1 ~ "Male", 0 ~ "Female"),
                             status = case_match(status, 1 ~ "Admitted", 0 ~ "Rejected"))

adm_cnf <- table(tmp_df)
adm_prv <- adm_cnf + rd

kbl(list(adm_cnf, adm_prv), booktabs = TRUE) %>%
  kable_styling(position = 'center', latex_options = c("hold_position"))


## ----echo = TRUE--------------------------------------------------------------
st_f <- function(i, xi, sdp) {
  if(xi[1] & xi[2]) {
    c(1,0,0,0)
  } else if (xi[1] & !xi[2]) {
    c(0,1,0,0)
  } else if (!xi[1] & xi[2]) {
    c(0,0,1,0)
  } else {
    c(0,0,0,1)
  }
}


## ----echo = TRUE--------------------------------------------------------------
priv_f <- function(sdp, tx) {
  sum(dapper::ddnorm(sdp - tx, mu = 0, sigma = 6.25, log = TRUE))
}


## ----echo = FALSE-------------------------------------------------------------
library(dapper)

dmod <- new_privacy(post_f   = post_f,
                    latent_f = latent_f,
                    priv_f   = priv_f,
                    st_f     = st_f,
                    npar     = 4,
                    varnames = c("pi_11", "pi_21", "pi_12", "pi_22"))
                  
dp_out <- dapper_sample(dmod,
                  sdp = c(131, 119, 47, 122),
                  niter = 2000,
                  warmup = 1000,
                  chains = 1,
                  init_par = rep(.25,4))


## ----echo = TRUE--------------------------------------------------------------
summary(dp_out)


## ----post-or-density-dg, fig.cap="(Example 2) posterior density estimate for the odds ratio using 1,000 MCMC draws.",  fig.height=3, fig.width=5, fig.align='center'----
tv <- dp_out$chain
or <- as.numeric((tv[,1] * tv[,4]) / (tv[,2] * tv[,3]))
ggplot(tibble(x=or), aes(x)) + geom_density() + xlim(0,8) + xlab("Odds Ratio")


## ----post-or-compare-dg, fig.cap= caption,  echo = FALSE, fig.height=3, fig.width=5, fig.align='center'----
caption <- "(Example 2) comparison between using dapper and a naive Bayesian anaylsis on the
noise infused data and the original confidential data." 

table_post <- function(x) {
    t1 <- rgamma(4, x + 1, 1)
    t1/sum(t1)
}

set.seed(1)
confidential_data <- c(109, 127, 46, 118)
cps <- t(sapply(1:1000, function(s) table_post(confidential_data)))
odds_male   <- cps[,1] / cps[,2]
odds_female <- cps[,3] / cps[,4]
odds_ratio_conf  <- odds_male/odds_female

set.seed(1)
sdp <- c(110, 131, 47, 110)
cps <- t(sapply(1:1000, function(s) table_post(sdp)))
odds_male   <- cps[,1] / cps[,2]
odds_female <- cps[,3] / cps[,4]
odds_ratio_noisy  <- odds_male/odds_female

df1 <- tibble(confidential = odds_ratio_conf, noisy = odds_ratio_noisy) %>%
  pivot_longer(everything(), names_to = "group", values_to = "odds_ratio") %>%
  mutate(method = "naive")

df2 <- tibble(confidential = odds_ratio_conf, noisy = or) %>%
  pivot_longer(everything(), names_to = "group", values_to = "odds_ratio") %>%
  mutate(method = "dapper")

df <- rbind(df1,df2)

df %>%  ggplot(aes(odds_ratio, group = group, fill = group)) + 
  geom_density(alpha = .5) + 
  facet_wrap(~method) + 
  xlim(0,8) +
  xlab("Odds Ratio") +
  guides(fill= guide_legend(title= "Data")) + 
  theme(legend.position="bottom")


## ----echo = TRUE--------------------------------------------------------------
latent_f <- function(theta) {
  xmat <- MASS::mvrnorm(50 , mu = c(.9,-1.17), Sigma = diag(2))
  y <- cbind(1,xmat) %*% theta + rnorm(50, sd = sqrt(2))
  cbind(y,xmat)
}


## ----echo = TRUE--------------------------------------------------------------
post_f <- function(dmat, theta) {
  x <- cbind(1,dmat[,-1])
  y <- dmat[,1]

  ps_s2 <- solve((1/2) * t(x) %*% x + (1/4) * diag(3))
  ps_m <- ps_s2 %*% (t(x) %*% y) * (1/2)

  MASS::mvrnorm(1, mu = ps_m, Sigma = ps_s2)
}


## ----echo = TRUE--------------------------------------------------------------
clamp_data <- function(dmat) {
  pmin(pmax(dmat,-10),10) / 10
}

st_f <- function(i, tx, sdp) {
  txc <- clamp_data(tx)
  ydp <- txc[1]
  xdp <- cbind(1,t(txc[-1]))
    
  s1 <- t(xdp) %*% ydp
  s2 <- t(ydp) %*% ydp
  s3 <- t(xdp) %*% xdp

  ur_s1 <- c(s1)
  ur_s2 <- c(s2)
  ur_s3 <- s3[upper.tri(s3,diag = TRUE)][-1]
  c(ur_s1,ur_s2,ur_s3)
}


## ----echo = TRUE--------------------------------------------------------------
priv_f <- function(sdp, zt) {
  sum(VGAM::dlaplace(sdp - zt, 0, 15/10, log = TRUE))
}


## ----echo = TRUE--------------------------------------------------------------
deltaa <- 15
epsilon <- 10
n <- 50

set.seed(1)
xmat <- MASS::mvrnorm(n, mu = c(.9,-1.17), Sigma = diag(2))
beta <- c(-1.79, -2.89, -0.66)
y <- cbind(1,xmat) %*% beta + rnorm(n, sd = sqrt(2))

#clamp the confidential data in xmat
dmat <- cbind(y,xmat)
sdp <-  apply(sapply(1:nrow(dmat), function(i) st_f(i, dmat[i,], sdp)), 1, sum)

#add Laplace noise 
sdp <- sdp + VGAM::rlaplace(length(sdp), location = 0, scale = deltaa/epsilon)


## ----echo = TRUE, cache = TRUE------------------------------------------------
library(dapper)

dmod <- new_privacy(post_f   = post_f,
                    latent_f = latent_f,
                    priv_f   = priv_f,
                    st_f     = st_f,
                    npar     = 3,
                    varnames = c("beta0", "beta1", "beta2"))



dp_out <- dapper_sample(dmod,
                        sdp = sdp,
                        niter = 25000,
                        warmup = 1000,
                        chains = 1,
                        init_par = rep(0,3))



## ----echo = TRUE--------------------------------------------------------------
summary(dp_out)


## ----echo = FALSE-------------------------------------------------------------
#x^Ty
s1 <- sdp[1:3]

#y^Ty
s2 <- sdp[4]

#x^Tx
s3 <- matrix(0, nrow = 3, ncol = 3)
s3[upper.tri(s3, diag = TRUE)] <- c(n, sdp[5:9])
s3[lower.tri(s3)] <- s3[upper.tri(s3)]


## ----echo = FALSE-------------------------------------------------------------
s3 <- pracma::nearest_spd(solve(s3))
bhat <- s3 %*% s1
sigma_hat <- 2^2 * s3


## ----regression-compare, fig.cap = caption, echo = FALSE, fig.height=3, fig.width=5, fig.align='center'----
caption <- "(Example 3) comparison between dapper and a naive approach that ignores the privacy mechanism. 
The dashed lines are the true coefficient values."

coef_df <- dp_out$chain %>% 
  as_tibble() %>%
  pivot_longer(contains("beta"), names_to = "coefficient", values_to = "estimate") %>%
  mutate(method = "dapper")

coef_med <- coef_df %>% 
  group_by(coefficient) %>%
  summarise(median = median(estimate))

coef_true <- tibble(coefficient = c("beta0", "beta1", "beta2"),
                    value  = c(-1.79, -2.89, -0.66))

naive_sample <- MASS::mvrnorm(9000, mu = bhat, Sigma = sigma_hat)

coef_post <- tibble(beta0 = naive_sample[,1],
                    beta1 = naive_sample[,2],
                    beta2 = naive_sample[,3])

coef_post <- coef_post %>% 
  pivot_longer(contains("beta"), names_to = "coefficient", values_to = "estimate") %>%
  mutate(method = "naive")

rbind(coef_df, coef_post) %>%
  ggplot(aes(x = estimate, group = method, fill = method)) + geom_density(alpha = .5) + 
  geom_vline(aes(xintercept = value), data = coef_true, linetype = "dashed") +
  facet_wrap(~coefficient, scale = 'free') + coord_cartesian(ylim=c(0, 0.7)) +
  theme(legend.position="bottom")


## ----regression-data-compare, fig.cap=caption, echo = FALSE, fig.height=3, fig.width=5, fig.align='center'----
caption <- "(Example 3) comparison for example between using dapper on the noisy data set and a standard
Bayesian analysis on the confidential data set."
coef_df <- dp_out$chain %>% 
  as_tibble() %>%
  pivot_longer(contains("beta"), names_to = "coefficient", values_to = "estimate") %>%
  mutate(data = "noisy")

xmt <- cbind(1,xmat)
conf_bhat <- solve(t(xmt) %*% xmt) %*% (t(xmt) %*% y)
conf_sigma_hat <- 2^2 * solve(t(xmt) %*% xmt)
conf_sample <- MASS::mvrnorm(9000, mu = conf_bhat, Sigma = conf_sigma_hat)


coef_post <- tibble(beta0 = conf_sample[,1],
                    beta1 = conf_sample[,2],
                    beta2 = conf_sample[,3])

coef_post <- coef_post %>% 
  pivot_longer(contains("beta"), names_to = "coefficient", values_to = "estimate") %>%
  mutate(data = "confidential")

rbind(coef_df, coef_post) %>%
  mutate(data = as_factor(data)) %>% 
  ggplot(aes(x = estimate, group = data, fill = data)) + geom_density(alpha = .5) + 
  geom_vline(aes(xintercept = value), data = coef_true, linetype = "dashed") +
  facet_wrap(~coefficient, scale = 'free') + coord_cartesian(ylim=c(0, 0.7)) +
  theme(legend.position="bottom")


