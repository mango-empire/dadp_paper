# Generated by `rjournal_pdf_article()` using `knitr::purl()`: do not edit by hand
# Please edit dppaper.Rmd to modify this file

## ----setup, include=FALSE-----------------------------------------------------
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
library(ggplot2)
library(kableExtra)
library(tidyverse)
library(knitr)


## ----echo=TRUE, eval=FALSE----------------------------------------------------
#> new_privacy(post_f = NULL, latent_f = NULL, priv_f = NULL,
#>             st_f = NULL, add = FALSE, npar = NULL)


## ----echo = TRUE, eval = FALSE------------------------------------------------
#> dapper_sample(data_model, sdp, init_par, niter = 2000, warmup = floor(niter / 2),
#>            chains = 1, varnames = NULL)


## ----echo = FALSE-------------------------------------------------------------
set.seed(1)
tmp <- apply(UCBAdmissions, 3, identity, simplify=FALSE)
adm_cnf <- Reduce('+', tmp)
adm_prv <- round(adm_cnf + rnorm(4, mean = 0, sd = 100), 2)


## ----echo = FALSE-------------------------------------------------------------
kbl(list(adm_cnf, adm_prv), booktabs = TRUE) %>%
  kable_styling(position = 'center', latex_options = c("hold_position"))


## ----echo = TRUE--------------------------------------------------------------
latent_f <- function(theta) {
  t(rmultinom(1, 4526, theta))
}


## ----echo = TRUE--------------------------------------------------------------
post_f <- function(dmat, theta) {
  x <- c(dmat)
  t1 <- rgamma(4, x + 1, 1)
  t1/sum(t1)
}


## ----echo = TRUE--------------------------------------------------------------
st_f <- function(dmat) {
  c(dmat)
}


## ----echo = TRUE--------------------------------------------------------------
priv_f <- function(sdp, x) {
  dnorm(sdp - x, mean = 0, sd = 100, log = TRUE)
}


## ----echo = TRUE--------------------------------------------------------------
set.seed(1)
tmp <- apply(UCBAdmissions, 3, identity, simplify=FALSE)
adm_cnf <- Reduce('+', tmp)
adm_prv <- round(adm_cnf + rnorm(4, mean = 0, sd = 100), 2)

x <- c(adm_cnf)
sdp <- c(adm_prv)


## ----echo = TRUE--------------------------------------------------------------
library(dapper)
dmod <- new_privacy(post_f   = post_f,
                    latent_f = latent_f,
                    priv_f   = priv_f,
                    st_f     = st_f,
                    add      = FALSE,
                    npar     = 4,
                    varnames = c("pi_11", "pi_21", "pi_12", "pi_22"))
                  
dp_out <- dapper_sample(dmod,
                  sdp = sdp,
                  niter = 10000,
                  warmup = 1000,
                  chains = 1,
                  init_par = rep(.25,4))


## ----eval = FALSE, echo = TRUE------------------------------------------------
#> library(furrr)
#> plan(multisession, workers = 2)
#> 
#> dp_out <- dapper_sample(dmod,
#>                   sdp = c(adm_prv),
#>                   niter = 10000,
#>                   warmup = 1000,
#>                   chains = 4,
#>                   init_par = rep(.25,4))


## ----eval = FALSE, echo = TRUE------------------------------------------------
#> library(progressr)
#> 
#> with_progress({
#>   dp_out <- dapper_sample(dmod,
#>                   sdp = c(adm_prv),
#>                   niter = 10000,
#>                   warmup = 1000,
#>                   chains = 4,
#>                   init_par = rep(.25,4))
#> })


## ----echo = FALSE-------------------------------------------------------------
summary(dp_out)


## ----trace-plot,  fig.cap="trace plots.", fig.height=3, fig.width=5, fig.align='center'----
plot(dp_out)


## ----post-or-density, fig.cap="posterior density estimate for the odds ratio using 9000 MCMC draws.",  fig.height=3, fig.width=5, fig.align='center'----
tv <- dp_out$chain
or <- as.numeric((tv[,1] * tv[,4]) / (tv[,2] * tv[,3]))
ggplot(tibble(x=or), aes(x)) + geom_density() + xlim(0,4) + xlab("Odds Ratio")


## ----post-or-compare, fig.cap="comparison.",  echo = FALSE, fig.height=3, fig.width=5, fig.align='center'----
set.seed(1)
confidential_data <- x
cps <- t(sapply(1:9000, function(s) post_f(confidential_data, NULL)))
odds_male   <- cps[,1] / cps[,2]
odds_female <- cps[,3] / cps[,4]
odds_ratio_conf  <- odds_male/odds_female

set.seed(1)
noisy_data <- sdp
cps <- t(sapply(1:9000, function(s) post_f(noisy_data, NULL)))
odds_male   <- cps[,1] / cps[,2]
odds_female <- cps[,3] / cps[,4]
odds_ratio_noisy  <- odds_male/odds_female

df1 <- tibble(confidential = odds_ratio_conf, noisy = odds_ratio_noisy) %>%
  pivot_longer(everything(), names_to = "group", values_to = "odds_ratio") %>%
  mutate(method = "naive")

df2 <- tibble(confidential = odds_ratio_conf, noisy = or) %>%
  pivot_longer(everything(), names_to = "group", values_to = "odds_ratio") %>%
  mutate(method = "dapper")

df <- rbind(df1,df2)

df %>%  ggplot(aes(odds_ratio, group = group, fill = group)) + 
  geom_density(alpha = .5) + 
  facet_wrap(~method) + 
  xlim(1,4) +
  xlab("Odds Ratio") +
  guides(fill= guide_legend(title= "Data"))


## ----echo = TRUE--------------------------------------------------------------
latent_f <- function(theta) {
  xmat <- MASS::mvrnorm(50 , mu = c(.9,-1.17), Sigma = diag(2))
  y <- cbind(1,xmat) %*% theta + rnorm(1, sd = sqrt(2))
  cbind(y,xmat)
}


## ----echo = TRUE--------------------------------------------------------------
post_f <- function(dmat, theta) {
  x <- cbind(1,dmat[,-1])
  y <- dmat[,1]

  ps_s2 <- solve((1/2) * t(x) %*% x + (1/4) * diag(3))
  ps_m <- ps_s2 %*% (t(x) %*% y) * (1/2)

  MASS::mvrnorm(1, mu = ps_m, Sigma = ps_s2)
}


## ----echo = TRUE--------------------------------------------------------------
clamp_data <- function(dmat) {
  pmin(pmax(dmat,-10),10) / 10
}

st_f <- function(dmat) {
  sdp_mat <- clamp_data(dmat)
  ydp <- sdp_mat[,1, drop = FALSE]
  xdp <- cbind(1,sdp_mat[,-1, drop = FALSE])

  s1 <- t(xdp) %*% ydp
  s2 <- t(ydp) %*% ydp
  s3 <- t(xdp) %*% xdp

  ur_s1 <- c(s1)
  ur_s2 <- c(s2)
  ur_s3 <- s3[upper.tri(s3,diag = TRUE)][-1]
  c(ur_s1,ur_s2,ur_s3)
}


## ----echo = TRUE--------------------------------------------------------------
#deltaa <- 13
#epsilon <- 10
priv_f <- function(sdp, zt) {
  sum(VGAM::dlaplace(sdp - zt, 0, 13/10, log = TRUE))
}


## ----echo = TRUE--------------------------------------------------------------
deltaa <- 13
epsilon <- 10
n <- 50

xmat <- MASS::mvrnorm(n, mu = c(.9,-1.17), Sigma = diag(2))
beta <- c(-1.79, -2.89, -0.66)
y <- cbind(1,xmat) %*% beta + rnorm(n, sd = sqrt(2))

#clamp the confidential data in xmat
sdp <- st_f(cbind(y,xmat))

#add Laplace noise 
sdp <- sdp + VGAM::rlaplace(length(sdp), location = 0, scale = deltaa/epsilon)


## ----echo = TRUE, cache = TRUE------------------------------------------------
library(progressr)

dmod <- new_privacy(post_f   = post_f,
                    latent_f = latent_f,
                    priv_f   = priv_f,
                    st_f     = st_f,
                    npar     = 3,
                    varnames = c("beta0", "beta1", "beta2"))


with_progress({
dp_out <- dapper_sample(dmod,
                        sdp = sdp,
                        niter = 25000,
                        warmup = 1000,
                        chains = 1,
                        init_par = rep(0,3))
})


## ----echo = TRUE--------------------------------------------------------------
#x^Ty
s1 <- sdp[1:3]

#y^Ty
s2 <- sdp[4]

#x^Tx
s3 <- matrix(0, nrow = 3, ncol = 3)
s3[upper.tri(s3, diag = TRUE)] <- c(100, sdp[5:9])
s3[lower.tri(s3)] <- s3[upper.tri(s3)]


## ----echo = TRUE--------------------------------------------------------------
s3 <- pracma::nearest_spd(solve(s3))
bhat <- s3 %*% s1
sigma_hat <- 2 * s3


## ----regression-compare, fig.cap="Comparison between dapper and a naive approach that ignores the privacy mechanism", echo = FALSE, fig.height=1.5, fig.width=5, fig.align='center'----
coef_df <- dp_out$chain %>% 
  as_tibble() %>%
  pivot_longer(contains("beta"), names_to = "coefficient", values_to = "estimate") %>%
  mutate(method = "dapper")

coef_med <- coef_df %>% 
  group_by(coefficient) %>%
  summarise(median = median(estimate))

coef_true <- tibble(coefficient = c("beta0", "beta1", "beta2"),
                    value  = c(-1.79, -2.89, -0.66))

naive_sample <- MASS::mvrnorm(9000, mu = bhat, Sigma = sigma_hat)

coef_post <- tibble(beta0 = naive_sample[,1],
                    beta1 = naive_sample[,2],
                    beta2 = naive_sample[,3])

coef_post <- coef_post %>% 
  pivot_longer(contains("beta"), names_to = "coefficient", values_to = "estimate") %>%
  mutate(method = "naive")

rbind(coef_df, coef_post) %>%
  ggplot(aes(x = estimate, group = method, fill = method)) + geom_density(alpha = .5) + 
  geom_vline(aes(xintercept = value), data = coef_true, linetype = "dashed") +
  facet_wrap(~coefficient, scale = 'free')

