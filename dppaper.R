# Generated by `rjournal_pdf_article()` using `knitr::purl()`: do not edit by hand
# Please edit dppaper.Rmd to modify this file

## ----setup, include=FALSE-----------------------------------------------------
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
library(ggplot2)
library(kableExtra)
library(tidyverse)
library(knitr)


## ----echo=TRUE, eval=FALSE----------------------------------------------------
#> new_privacy(post_f = NULL, latent_f = NULL, priv_f = NULL,
#>             st_f = NULL, add = FALSE, npar = NULL)


## ----echo = TRUE, eval = FALSE------------------------------------------------
#> dapper_sample(data_model, sdp, nobs, init_par, niter = 2000, warmup = floor(niter / 2),
#>            chains = 1, varnames = NULL)


## ----echo = FALSE-------------------------------------------------------------
set.seed(1)
tmp <- apply(UCBAdmissions, 3, identity, simplify=FALSE)
adm_cnf <- Reduce('+', tmp)
adm_prv <- round(adm_cnf + rnorm(4, mean = 0, sd = 100))


## ----echo = FALSE-------------------------------------------------------------
kbl(list(adm_cnf, adm_prv), booktabs = TRUE) %>%
  kable_styling(position = 'center', latex_options = c("hold_position"))


## ----echo = FALSE-------------------------------------------------------------
#generate 2x2 table data
x <- c(adm_cnf)
sdp <- c(adm_prv)


## ----echo = TRUE--------------------------------------------------------------
latent_f <- function(theta) {
  t(rmultinom(1, 4526, theta))
}


## ----echo = TRUE--------------------------------------------------------------
post_f <- function(dmat, theta) {
  x <- c(dmat)
  t1 <- rgamma(4, x + 1, 1)
  t1/sum(t1)
}


## ----echo = TRUE--------------------------------------------------------------
st_f <- function(dmat) {
  c(dmat)
}


## ----echo = TRUE--------------------------------------------------------------
priv_f <- function(sdp, x) {
  dnorm(sdp - x, mean = 0, sd = 100, log = TRUE)
}


## ----echo = TRUE--------------------------------------------------------------
library(dapper)
dmod <- new_privacy(post_f   = post_f,
                    latent_f = latent_f,
                    priv_f   = priv_f,
                    st_f     = st_f,
                    add      = FALSE,
                    npar     = 4,
                    varnames = c("pi_11", "pi_21", "pi_12", "pi_22"))
                  
dp_out <- dapper_sample(dmod,
                  sdp = c(adm_prv),
                  niter = 10000,
                  warmup = 1000,
                  chains = 1,
                  init_par = rep(.25,4))


## ----echo = FALSE-------------------------------------------------------------
summary(dp_out)


## ----fig.height=3, fig.width=5, fig.align='center'----------------------------
plot(dp_out)


## ----post-or-density, fig.cap="posterior density estimate for the odds ratio using 9000 MCMC draws.",  fig.height=3, fig.width=5, fig.align='center'----
tv <- dp_out$chain
or <- as.numeric((tv[,1] * tv[,4]) / (tv[,2] * tv[,3]))
ggplot(tibble(x=or), aes(x)) + geom_density() + xlim(0,4) + xlab("Odds Ratio")


## ----post-or-compare, fig.cap="comparison.",  echo = FALSE, fig.height=1.5, fig.width=5, fig.align='center'----
set.seed(1)
confidential_data <- c(1198, 1493, 557, 1278)
cps <- t(sapply(1:9000, function(s) post_f(confidential_data, NULL)))
odds_male   <- cps[,1] / cps[,2]
odds_female <- cps[,3] / cps[,4]
odds_ratio_conf  <- odds_male/odds_female

set.seed(1)
noisy_data <- c(1135, 1511, 473, 1438)
cps <- t(sapply(1:9000, function(s) post_f(noisy_data, NULL)))
odds_male   <- cps[,1] / cps[,2]
odds_female <- cps[,3] / cps[,4]
odds_ratio_noisy  <- odds_male/odds_female

p1 <- tibble(confidential = odds_ratio_conf, noisy = odds_ratio_noisy) %>%
  pivot_longer(everything(), names_to = "group", values_to = "odds_ratio") %>%
  ggplot(aes(odds_ratio, group = group, fill = group)) + geom_density(alpha = .5) + xlim(1,4)


p2 <- tibble(confidential = odds_ratio_conf, dapper = or) %>%
  pivot_longer(everything(), names_to = "group", values_to = "odds_ratio") %>%
  ggplot(aes(odds_ratio, group = group, fill = group)) + geom_density(alpha = .5) + xlim(1,4)


gridExtra::grid.arrange(p1,p2, nrow = 1)



## ----echo = TRUE--------------------------------------------------------------
latent_f <- function(theta) {
  xmat <- MASS::mvrnorm(100 , mu = c(.9,-1.17), Sigma = diag(2))
  y <- cbind(1,xmat) %*% theta + rnorm(1, sd = sqrt(2))
  cbind(y,xmat)
}


## ----echo = TRUE--------------------------------------------------------------
post_f <- function(dmat, theta) {
  x <- cbind(1,dmat[,-1])
  y <- dmat[,1]

  ps_s2 <- solve((1/2) * t(x) %*% x + (1/4) * diag(3))
  ps_m <- ps_s2 %*% (t(x) %*% y) * (1/2)

  MASS::mvrnorm(1, mu = ps_m, Sigma = ps_s2)
}


## ----echo = TRUE--------------------------------------------------------------
clamp_data <- function(dmat) {
  pmin(pmax(dmat,-10),10) / 10
}

st_f <- function(dmat) {
  sdp_mat <- clamp_data(dmat)
  ydp <- sdp_mat[,1, drop = FALSE]
  xdp <- cbind(1,sdp_mat[,-1, drop = FALSE])

  s1 <- t(xdp) %*% ydp
  s2 <- t(ydp) %*% ydp
  s3 <- t(xdp) %*% xdp

  ur_s1 <- c(s1)
  ur_s2 <- c(s2)
  ur_s3 <- s3[upper.tri(s3,diag = TRUE)][-1]
  c(ur_s1,ur_s2,ur_s3)
}


## ----echo = TRUE--------------------------------------------------------------
#deltaa <- 13
#epsilon <- 10
priv_f <- function(sdp, zt) {
  sum(VGAM::dlaplace(sdp - zt, 0, 13/10, log = TRUE))
}


## ----echo = TRUE, eval = FALSE------------------------------------------------
#> deltaa <- 13
#> epsilon <- 10
#> n <- 100
#> xmat <- MASS::mvrnorm(n, mu = c(.9,-1.17), Sigma = diag(2))
#> beta <- c(-1.79, -2.89, -0.66)
#> y <- cbind(1,xmat) %*% beta + rnorm(n, sd = sqrt(2))
#> z <- st_f(cbind(y,xmat))
#> z <- z + VGAM::rlaplace(length(z), location = 0, scale = deltaa/epsilon)
#> 
#> dmod <- new_privacy(post_f   = post_f,
#>                     latent_f = latent_f,
#>                     priv_f   = priv_f,
#>                     st_f     = st_f,
#>                     npar     = 3,
#>                     varnames = c("beta0", "beta1", "beta2"))
#> 
#> dp_out <- dapper_sample(dmod,
#>                         sdp = z,
#>                         niter = 3000,
#>                         warmup = 1000,
#>                         chains = 1,
#>                         init_par = rep(0,3))


## -----------------------------------------------------------------------------
summary(dp_out)


## -----------------------------------------------------------------------------
plot(dp_out)

